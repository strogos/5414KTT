/*
 * Timer.cpp
 *
 *  Created on: Apr 23, 2015
 *      Author: bengteh
 */



#include "Timer.h"
#include "ace/Log_Msg.h"

Timer::Timer(long time_out, ACE_Reactor * reac) : done_(false), reactor_(reac)
{

	timer_id_=reactor_->schedule_timer(this,  				//timer handler
									(const void *)0, // argument (arg) sent to handle_timeout()
									ACE_Time_Value(time_out)); 	//delay before going off

//	open(0);
}

Timer::~Timer(){}

int Timer::handle_timeout (const ACE_Time_Value &tv,const void *arg)
{
	ACE_DEBUG ((LM_DEBUG, "Timer #%d timed out at %d!\n",
				 timer_id_, tv.sec()));
	done_=true;
	//Keep yourself registered with the Reactor.
	return 0;
}


int Timer::get_id(){return timer_id_;}
bool Timer::is_done(){return done_;}
void Timer::cancel_timer(int timer_id)
{
	reactor_->cancel_timer(timer_id);
	done_=true;
}

class Timer::Handler : public ACE_Task<ACE_MT_SYNCH>
{
	public:
		Handler(ACE_Reactor * reac,std::atomic<bool> * done)
								:done_(done),reactor_(reac)
		{}
		~Handler(){}

		int open(void*)
		{
			ACE_DEBUG((LM_DEBUG,
								"(%t) Active Timer Object opened \n"));
			//activate object with a thread in it
			//this->activate(THR_NEW_LWP | THR_SUSPENDED,1); //using a kernel thread
			activate();
			return 0;
		}

		int close(u_long)
		{
			ACE_DEBUG((LM_DEBUG, "(%t) Active Timer Object is being closed down \n"));
			return 0;
		}

		int svc(void)
		{
			ACE_DEBUG((LM_DEBUG, "(%t) servicing Timer events \n"));
			while (!this->done_)
			{
				this->reactor_->handle_events();
			}
			return 0;
		}
	private:
		std::atomic<bool> * done_;
		ACE_Reactor *reactor_=nullptr;
};
