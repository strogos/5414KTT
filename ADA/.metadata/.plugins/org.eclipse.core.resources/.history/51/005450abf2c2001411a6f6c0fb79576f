-- NOTES:
-- task<=>thread
-- access<=> pointer

with Ada.Text_IO, Ada.Integer_Text_IO, Ada.Numerics.Float_Random;
use Ada.Text_IO, Ada.Integer_Text_IO, Ada.Numerics.Float_Random;


procedure exercise8 is
   Count_Failed : exception; -- Exception to be raised when counting fails
   Gen : Generator; -- Random number generator

   protected type Transaction_Manager (N : Positive) is
      entry Finished;
      entry Wait_Until_Aborted;
      procedure Signal_Abort;
   private
      Finished_Gate_Open : Boolean := False;
      Aborted : Boolean := False;
   end Transaction_Manager;

   protected body Transaction_Manager is
      entry Finished when Finished_Gate_Open or Finished'Count = N is
      begin

         --wait for all threads (tasks) to finish and make sure all votes are counted
         Put_Line("A thread is Finished: Threads blocked/remaining ="& Integer'Image(Finished'Count)
                  &"; Did a thread ABORT? :"&Boolean'Image(Aborted));

         --On first thread arrival/finish; OPEN GATE for remaining threads.
         if (Finished'Count=(N-1)) then
            Finished_Gate_Open:=True;
         end if;

         --On last thread arrival/finish; CLOSE gate for next "thread run"
         if Finished'Count = 0 then
            Finished_Gate_Open:=False;
         end if;

      end Finished;
      ------------------------------------------
      -- PART 2 & 3: Create the Wait_Until_Aborted entry
      ------------------------------------------
      entry Wait_Until_Aborted when Aborted is
      begin
         Put_Line("Did a thread ABORT? :"&Boolean'Image(Aborted)&" Wait_Until_Aborted entry triggered-> Number of threads NOT here: "&Integer'Image( Wait_Until_Aborted'Count));
         if Wait_Until_Aborted'Count = 0 then
            Aborted:=False;
         end if;
      end Wait_Until_Aborted;

      procedure Signal_Abort is
      begin
         Aborted := True;
      end Signal_Abort;

   end Transaction_Manager;


   function Unreliable_Slow_Add (x : Integer) return Integer is
      Error_Rate : Constant := 0.15; -- (between 0 and 1)
      Random_Number : Float := 0.0;
   begin
      Random_Number := Random(Gen);

      if Random_Number <= Error_Rate then
         delay Duration(Random_Number*0.5);
         raise Count_Failed;
      else
         delay Duration(random_number*4.0);
         return (10+x);
      end if;

   end Unreliable_Slow_Add;


   task type Transaction_Worker (Initial : Integer; Manager : access Transaction_Manager);
   task body Transaction_Worker is
      Num : Integer := Initial;
      Prev : Integer := Num;
      Round_Num : Integer := 0;
   begin
      Put_Line ("Worker" & Integer'Image(Initial) & " started");

      loop
         Put_Line ("Worker" & Integer'Image(Initial) & " started round" & Integer'Image(Round_Num));
         Round_Num := Round_Num + 1;
         ---------------------------------------
         -- PART 1: Select-Then-Abort
         ---------------------------------------
         select
            Manager.Wait_Until_Aborted; -->triggering alternative!
            -- code below runs when the triggering_alternative has triggered
            Num:=Prev+5;
            Put_Line("Worker"&Integer'Image(Initial)&"-> forward error recovery triggered! - COMPENSATING:"
                      &" Previous commit:" & Integer'Image(Prev) & ". Adding 5 -> Now committing: "&Integer'Image(Num));
         then abort
         --else: --(seriously shitty syntax here...)
            begin
               Num:=Unreliable_Slow_Add(Num);
               Put_Line (" Worker" & Integer'Image(Initial) & " comitting" & Integer'Image(Num));
               Manager.Finished;
            exception
               When Count_Failed =>
                  begin
                     Manager.Signal_Abort;
                     Put_Line( "Worker" & Integer'Image(Initial)&" told TM to abort!");
                  end;
            end;
          end select;

         Prev := Num;
         delay 2.0;

      end loop;
   end Transaction_Worker;

   Manager : aliased Transaction_Manager (3);

   Worker_1 : Transaction_Worker (0, Manager'Access);
   Worker_2 : Transaction_Worker (1, Manager'Access);
   Worker_3 : Transaction_Worker (2, Manager'Access);

begin
   Reset(Gen); -- Seed the random number generator
end exercise8;